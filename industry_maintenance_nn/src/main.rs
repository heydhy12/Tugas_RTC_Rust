use industry_maintenance_nn::{
    data::{dataset::Dataset, preprocessing},
    model::neural_net::NeuralNetwork,
    training::trainer,
    utils::metrics,
};
use std::{error::Error, fs};
use serde_json;

fn main() -> Result<(), Box<dyn Error>> {
    // Load and prepare data
    let dataset = Dataset::from_csv("csv/industry_maintenance.csv")?;

    println!("Original Dataset Size: {} samples", dataset.features.nrows());
    println!("Features Shape: {}x{}", dataset.features.nrows(), dataset.features.ncols());
    println!("Labels Shape: {}x{}", dataset.labels.nrows(), dataset.labels.ncols());
    
    // Split data (80% train, 20% test)
    let mut split_data = dataset.split_data(0.2, true);

    println!("\nData Split Information:");
    println!("Training Set Size: {} samples ({:.1}%)", 
        split_data.train_features.nrows(), 
        split_data.train_features.nrows() as f32 / dataset.features.nrows() as f32 * 100.0);
    println!("Test Set Size: {} samples ({:.1}%)",
        split_data.test_features.nrows(),
        split_data.test_features.nrows() as f32 / dataset.features.nrows() as f32 * 100.0);
    
    // Normalize data
    preprocessing::normalize_zscore(&mut split_data.train_features);
    preprocessing::normalize_zscore(&mut split_data.test_features);

    let model_path = "model.json";
    let plot_path = "training_progress.png";
    let history_path = "training_history.json";

    // Initialize model
    let mut nn = if let Ok(model_json) = fs::read_to_string(model_path) {
        println!("");  
        println!("Model is available: {}", model_path);
        serde_json::from_str(&model_json)?
    } else {
        println!(""); 
        println!("Initializing new model...");
        NeuralNetwork::new(4, 17, 15, 4)  // Sesuaikan dengan arsitektur jaringan Anda
    };

    // Training parameters
    let learning_rate = 0.0001;
    let epochs = 3000;
    let print_every = 100; 

    // Train only if the model was not available
    if fs::metadata(model_path).is_err() {
        println!("Training Plot will be saved to: {}", plot_path);
        println!(""); 

        let training_metrics = trainer::train(
            &mut nn,
            &split_data.train_features,
            &split_data.train_labels,
            Some(&split_data.test_features), 
            Some(&split_data.test_labels),   
            learning_rate,
            epochs,
            print_every,
        );

        // Save trained model
        let serialized_model = serde_json::to_string(&nn)?;
        fs::write(model_path, serialized_model)?;
        println!("Model saved to {}", model_path);

        // Save Training History
        let metrics_json = serde_json::to_string_pretty(&training_metrics)?;
        fs::write(history_path, metrics_json)?;
        println!("Training metrics saved to {}", history_path);

        // Plot will be automatically generated by the train function
    } else {
        println!("Skipping training as model already exists at {}", model_path);
        println!("To retrain, delete the existing model file.");
    }

    // Evaluate on training set
    let train_predictions = trainer::predict(&nn, &split_data.train_features);
    let train_acc = metrics::accuracy(&train_predictions, &split_data.train_labels);
    println!("\nTraining Set Accuracy: {:.2}%", train_acc * 100.0);

    // Evaluate model on test set
    let test_predictions = trainer::predict(&nn, &split_data.test_features);
    let test_acc = metrics::accuracy(&test_predictions, &split_data.test_labels);
    println!("Test Set Accuracy: {:.2}%", test_acc * 100.0);

    Ok(())
}