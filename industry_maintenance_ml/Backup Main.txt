use linfa::prelude::*;
use linfa_logistic::MultiLogisticRegression;
use ndarray::{Array1, Array2, Axis, s};
use csv::ReaderBuilder;
use std::fs::File;
use rand::thread_rng;
use rand::seq::SliceRandom;
use plotters::prelude::*;
use std::io::{self, Write};

// 1) Jarak Euclidean
fn euclidean_distance(a: &Array1<f64>, b: &Array1<f64>) -> f64 {
    a.iter()
        .zip(b.iter())
        .map(|(x, y)| (x - y).powi(2))
        .sum::<f64>()
        .sqrt()
}

// 2) Membuat plot
fn plot_svm_neighbors(
    train: &Array2<f64>,
    train_labels: &Array1<usize>,
    test: &Array2<f64>,
    test_label: usize,  
    file_name: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    // Test Label
    let caption = format!("SVM Neighbors (Predicted: {})", 
        match test_label {
            0 => "No Failure",
            1 => "Heat Dissipation Failure",
            2 => "Overstrain Failure",
            3 => "Power Failure",
            _ => "Unknown",
        }
    );

    let root = BitMapBackend::new(file_name, (800, 600)).into_drawing_area();
    root.fill(&WHITE)?;

    // Batas Plot
    let x_min = train.column(0).iter().chain(test.column(0).iter()).fold(f64::INFINITY, |a, &b| a.min(b));
    let x_max = train.column(0).iter().chain(test.column(0).iter()).fold(f64::NEG_INFINITY, |a, &b| a.max(b));
    let y_min = train.column(1).iter().chain(test.column(1).iter()).fold(f64::INFINITY, |a, &b| a.min(b));
    let y_max = train.column(1).iter().chain(test.column(1).iter()).fold(f64::NEG_INFINITY, |a, &b| a.max(b));

    // Buat chart
    let mut chart = ChartBuilder::on(&root)
        .caption(caption.as_str(), ("sans-serif", 30).into_font())
        .margin(10)
        .x_label_area_size(40)
        .y_label_area_size(40)
        .build_cartesian_2d(x_min..x_max, y_min..y_max)?;

    // Label Sumbu
    chart
        .configure_mesh()
        .x_desc("Feature 1")
        .y_desc("Feature 2")
        .draw()?;

    // Gambar titik data latih
    for (i, label) in train_labels.iter().enumerate() {
        let color = match label {
            0 => GREEN,
            1 => RED,
            2 => BLUE,
            3 => YELLOW,
            _ => BLACK,
        };
        chart.draw_series(PointSeries::of_element(
            vec![(train[[i, 0]], train[[i, 1]])],
            5,
            ShapeStyle::from(&color).filled(),
            &|coord, size, style| EmptyElement::at(coord) + Circle::new((0, 0), size, style),
        ))?;
    }

    // Gambar titik data uji
    chart.draw_series(PointSeries::of_element(
        vec![(test[[0, 0]], test[[0, 1]])],
        10,
        ShapeStyle::from(&BLACK).filled(),
        &|coord, size, style| EmptyElement::at(coord) + Circle::new((0, 0), size, style),
    ))?;

    // Simpan plot
    root.present()?;
    println!("Plot disimpan sebagai {}", file_name);

    Ok(())
}

// 3) KNN Predict Algoritma
fn knn_predict(
    train: &Array2<f64>,
    train_labels: &Array1<usize>,
    test: &Array2<f64>,
    k: usize,
) -> Array1<usize> {
    let mut predictions = Array1::zeros(test.nrows());

    for (i, test_sample) in test.axis_iter(Axis(0)).enumerate() {
        let distances = train
            .axis_iter(Axis(0))
            .map(|train_sample| euclidean_distance(&train_sample.to_owned(), &test_sample.to_owned()))
            .collect::<Vec<_>>();

        let mut nearest_indices = (0..distances.len()).collect::<Vec<_>>();
        nearest_indices.sort_by(|&a, &b| distances[a].partial_cmp(&distances[b]).unwrap());
        let nearest_indices = &nearest_indices[..k];

        let mut label_counts = std::collections::HashMap::new();
        for &idx in nearest_indices {
            let label = train_labels[idx];
            *label_counts.entry(label).or_insert(0) += 1;
        }

        let prediction = label_counts
            .into_iter()
            .max_by_key(|&(_, count)| count)
            .map(|(label, _)| label)
            .unwrap_or(0);

        predictions[i] = prediction;
    }

    predictions
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    
    // 4) Baca dataset
    let file = File::open("csv/industry_maintenance.csv")?;
    let mut rdr = ReaderBuilder::new().has_headers(true).from_reader(file);

    let mut records: Vec<_> = rdr.records().collect::<Result<_, _>>()?;
    let mut rng = rand::thread_rng();
    records.shuffle(&mut rng);

    // 5) Fitur dan Label
    let mut features = Vec::new();
    let mut labels = Vec::new();

    for record in &records {
        let feat: Vec<f64> = (0..4)
            .map(|i| record[i].trim().parse::<f64>().unwrap_or(0.0)) // Tangani kesalahan parsing
            .collect();
        features.push(feat);

        let label = match record[4].trim().to_lowercase().as_str() {
            "no failure" => 0,
            "heat dissipation failure" => 1,
            "overstrain failure" => 2,
            "power failure" => 3,
            _ => 0,
        };
        labels.push(label);
    }

    // 6) Konversi ke Array2 dan Array1
    let mut features = Array2::from_shape_vec((features.len(), 4), features.concat())?;
    let labels = Array1::from_vec(labels);

    // Normalisasi Data
    for mut col in features.axis_iter_mut(ndarray::Axis(1)) {
        let mean = col.mean().unwrap();
        let std = col.std(0.0);
        col.iter_mut().for_each(|x| *x = (*x - mean) / std);
    }

    // 7) Dataset 80 - 20
    let (train, test) = linfa::dataset::Dataset::new(features, labels)
        .split_with_ratio(0.8);

    // 8) Training model SVM (Logistic Regression)
    let svm_model = MultiLogisticRegression::default()
        .max_iterations(100)
        .fit(&train)?;

    // 9) Prediksi dan Evaluasi model SVM
    let svm_pred = svm_model.predict(&test);
    let svm_accuracy = svm_pred.iter()
        .zip(test.targets().iter())
        .filter(|(p, t)| p == t)
        .count() as f32 / test.nsamples() as f32;

    println!("Akurasi Model SVM: {:.2}%", svm_accuracy * 100.0);

    // 10) Plot hasil prediksi SVM
    let test_sample = test.records().slice(s![0..1, ..]).to_owned(); // Ambil satu sampel untuk plot
    let test_label = svm_pred[0];
    plot_svm_neighbors(
        train.records(),
        train.targets(),
        &test_sample,
        test_label,
        "svm_neighbors.png",
    ).expect("Gagal membuat plot");

    // 11) Evaluasi model KNN (Manual)
    let knn_pred = knn_predict(train.records(), train.targets(), test.records(), 5); // k = 5
    let knn_accuracy = knn_pred.iter()
        .zip(test.targets().iter())
        .filter(|(p, t)| p == t)
        .count() as f32 / test.nsamples() as f32;

    println!("Akurasi Model KNN: {:.2}%", knn_accuracy * 100.0);

    // 12) Ambil 10 sampel secara acak dari data test
    let mut rng = thread_rng();
    let mut indices: Vec<usize> = (0..test.nsamples()).collect(); // Indeks data test
    indices.shuffle(&mut rng); // Acak indeks
    let selected_indices = &indices[0..10]; // Ambil 10 indeks pertama setelah diacak

    let test_samples = test.records().select(ndarray::Axis(0), selected_indices);
    let test_labels = test.targets().select(ndarray::Axis(0), selected_indices);

    // 13) Prediksi 10 sampel dengan SVM dan KNN
    let svm_predictions = svm_model.predict(&test_samples);
    let knn_predictions = knn_predict(train.records(), train.targets(), &test_samples, 5);

    // 14) Hasil prediksi 10 Sampel
    println!("\nHasil Prediksi untuk 10 Sampel dari Data Test:");
    for (i, ((svm_pred, knn_pred), actual)) in svm_predictions.iter()
        .zip(knn_predictions.iter())
        .zip(test_labels.iter())
        .enumerate()
    {
        let svm_category = match svm_pred {
            0 => "No Failure",
            1 => "Heat Dissipation Failure",
            2 => "Overstrain Failure",
            3 => "Power Failure",
            _ => "Unknown",
        };
        let knn_category = match knn_pred {
            0 => "No Failure",
            1 => "Heat Dissipation Failure",
            2 => "Overstrain Failure",
            3 => "Power Failure",
            _ => "Unknown",
        };
        let actual_category = match actual {
            0 => "No Failure",
            1 => "Heat Dissipation Failure",
            2 => "Overstrain Failure",
            3 => "Power Failure",
            _ => "Unknown",
        };
        println!(
            "Sampel {}: Prediksi SVM = {}, Prediksi KNN = {}, Aktual = {}",
            i + 1, svm_category, knn_category, actual_category
        );
    }

        // 15) Input manual dari pengguna
        println!("\nMasukkan parameter untuk prediksi manual:");
        let mut input = String::new();
    
        print!("air_temperature_k: ");
        io::stdout().flush()?;
        io::stdin().read_line(&mut input)?;
        let air_temperature_k: f64 = input.trim().parse()?;
        input.clear();
    
        print!("process_temperature_k: ");
        io::stdout().flush()?;
        io::stdin().read_line(&mut input)?;
        let process_temperature_k: f64 = input.trim().parse()?;
        input.clear();
    
        print!("rotational_speed_rpm: ");
        io::stdout().flush()?;
        io::stdin().read_line(&mut input)?;
        let rotational_speed_rpm: f64 = input.trim().parse()?;
        input.clear();
    
        print!("torsi_nm: ");
        io::stdout().flush()?;
        io::stdin().read_line(&mut input)?;
        let torsi_nm: f64 = input.trim().parse()?;
    
        // Normalisasi Input Manual
        let manual_input = Array2::from_shape_vec((1, 4), vec![
            air_temperature_k,
            process_temperature_k,
            rotational_speed_rpm,
            torsi_nm,
        ])?;
    
        // 16) Prediksi dengan SVM
        let svm_manual_prediction = svm_model.predict(&manual_input);
        let svm_predicted_category = match svm_manual_prediction[0] {
            0 => "No Failure",
            1 => "Heat Dissipation Failure",
            2 => "Overstrain Failure",
            3 => "Power Failure",
            _ => "Unknown",
        };
    
        // 17) Prediksi dengan KNN (Manual)
        let knn_manual_prediction = knn_predict(
            train.records(),
            train.targets(),
            &manual_input,
            5, 
        );
        let knn_predicted_category = match knn_manual_prediction[0] {
            0 => "No Failure",
            1 => "Heat Dissipation Failure",
            2 => "Overstrain Failure",
            3 => "Power Failure",
            _ => "Unknown",
        };
    
        println!("\nHasil Prediksi Input Manual:");
        println!("Prediksi SVM: {}", svm_predicted_category);
        println!("Prediksi KNN: {}", knn_predicted_category);

    Ok(())
}

=======================================================================================================
=======================================================================================================
=======================================================================================================


use std::io::{self, Write};

fn main (
    // Handle manual input
    handle_manual_input(&train, &svm_model)?;
)   

fn handle_manual_input(
    train: &DatasetBase<Array2<f64>, Array1<usize>>,
    svm_model: &SVMModel,
) -> Result<(), Box<dyn std::error::Error>> {
    println!("\nMasukkan parameter untuk prediksi manual:");

    let air_temp = get_input_value("air_temperature_k: ")?;
    let process_temp = get_input_value("process_temperature_k: ")?;
    let rotational_speed = get_input_value("rotational_speed_rpm: ")?;
    let torque = get_input_value("torsi_nm: ")?;

    let manual_input = Array2::from_shape_vec((1, 4), vec![
        air_temp,
        process_temp,
        rotational_speed,
        torque,
    ])?;

    let svm_pred = svm_model.predict(&manual_input);
    let knn_pred = knn_predict(train.records(), train.targets(), &manual_input, 5);

    println!("\nHasil Prediksi Input Manual:");
    println!("Prediksi SVM: {}", get_failure_type(svm_pred[0]));
    println!("Prediksi KNN: {}", get_failure_type(knn_pred[0]));

    Ok(())
}

fn get_input_value(prompt: &str) -> Result<f64, Box<dyn std::error::Error>> {
    let mut input = String::new();
    print!("{}", prompt);
    io::stdout().flush()?;
    io::stdin().read_line(&mut input)?;
    Ok(input.trim().parse()?)
}
    